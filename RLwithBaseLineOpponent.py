#harshit
inp = [['3', '0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0', '3'],
       ['0', '0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0', '0'], ['0', '0', '0', '3', '0', '0']]

inp1 = [['3', '0', '0', '0', '0', '0','0'], ['0', '3', '0', '0', '0', '0','0'], ['0', '0', '0', '0', '0','0', '3'],
       ['0', '0', '3', '0', '0', '0','0'], ['0', '0', '0', '3', '0', '0','0'], ['0', '0', '0', '3', '0', '0','0']]

inp2 = [['3', '0', '0', '0', '0', '0','0','0'], ['0', '3', '0', '0', '0', '0','0','0'], ['0', '0', '0', '0', '0','0', '3', '0'],
       ['0', '0', '3', '0', '0', '0','0','0'], ['0', '0', '0', '3', '0', '0','0','0'], ['0', '0', '0', '3', '0', '0','0','3'],
        ['3', '0', '0', '0', '0', '0','0','0'],['3', '0', '0', '0', '0', '0','0','0']]

inp3 = [['3', '0', '0', '0', '0', '3'], ['0', '0', '0', '0', '3', '0'], ['0', '0', '0', '0', '0', '3'],
       ['0', '3', '0', '3', '0', '0'], ['3', '0', '0', '0', '0', '0'], ['0', '0', '0', '3', '0', '0']]

inp4 = [['3', '0', '0', '0', '0', '3','0'], ['0', '0', '0', '0', '3', '0','0'], ['0', '0', '0', '0', '0', '3','0'],
       ['0', '3', '0', '3', '0', '0','0'], ['3', '0', '0', '0', '0', '0','0'], ['0', '0', '0', '3', '0', '0','0'],['0', '0', '0', '3', '0', '0','0']]


#nidhi
inp5 = [['3', '0', '0', '0', '0', '0','0'], ['3', '0', '0', '0', '0', '0','0'], ['0', '0', '0', '0', '0', '3','0'],
       ['0', '0', '0', '3', '0', '0','0'], ['0', '0', '0', '0', '0', '0','0'], ['3', '0', '0', '3', '0', '0','0'],['0', '0', '0', '0', '0', '0','0']]

inp6 = [['3', '0', '0', '0', '0', '0'], ['0', '3', '0', '0', '0', '0'], ['3', '0', '0', '0', '0', '3'],
       ['3', '0', '3', '0', '0', '0'], ['0', '0', '0', '3', '0', '0'], ['0', '0', '0', '3', '0', '0']]

inp7 = [['3', '0', '0', '0', '0', '0','0','3','0'],['0', '3', '0', '0', '0', '0','3','0','0'], ['0', '3', '0', '0', '0', '0','3','0','0'],['0', '3', '0', '0', '0', '0','3','0','0'], ['3', '0', '0', '0', '0','0', '3', '0','0'],
       ['3', '0', '3', '0', '0', '0','0','0','0'],['0', '3', '0', '0', '0', '0','3','0','0'], ['3', '0', '0', '3', '0', '0','0','0','0'], ['3', '0', '0', '3', '0', '0','0','0','3']]

inp8 = [['3', '0', '3', '0', '0', '3'], ['0', '3', '0', '0', '3', '0'], ['0', '0', '0', '0', '0', '3'],
       ['0', '3', '0', '3', '0', '0'], ['3', '0', '3', '0', '0', '0'], ['3', '0', '0', '3', '0', '0']]

inp9 = [['3', '0', '0', '0', '0', '0','0','3','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'], ['0', '3', '0', '0', '0', '0','3','0','0','0'], ['3', '0','0', '0', '0', '0','0', '3', '0','0'],
       ['3', '0', '3', '0', '0', '0','0','0','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'], ['3', '0', '0', '3', '0', '0','0','0','0','0'], ['3', '0', '0', '3', '0', '0','0','0','3','0']]

#riya
inp10 = [['3', '0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0', '3'],
       ['0', '0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0', '0'], ['0', '0', '0', '3', '0', '0']]

inp11 = [['3', '0', '0', '0', '0', '0','0'], ['0', '3', '0', '0', '0', '0','0'], ['0', '0', '0', '0', '0','0', '3'],
       ['0', '0', '3', '0', '0', '0','0'], ['0', '0', '0', '3', '0', '0','0'], ['0', '0', '0', '3', '0', '0','0']]
inp12 = [['3', '0', '0', '0', '0', '0','0','3','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'], ['0', '3', '0', '0', '0', '0','3','0','0','0'], ['3', '0','0', '0', '0', '0','0', '3', '0','0'],
       ['3', '0', '3', '0', '0', '0','0','0','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'],['3', '0', '0', '3', '0', '0','0','0','0','0'], ['3', '0', '0', '3', '0', '0','0','0','0','0'], ['3', '0', '0', '3', '0', '0','0','0','3','0']]

inp13 = [['3', '0', '3', '0', '0', '3'], ['0', '3', '0', '0', '3', '0'], ['0', '0', '0', '0', '0', '3'],
       ['0', '3', '0', '3', '0', '0'], ['3', '0', '3', '0', '0', '0'], ['3', '0', '0', '3', '0', '0']]
inp14 = [['3', '0', '0', '0', '0', '3','0'], ['0', '0', '0', '0', '3', '0','0'], ['0', '0', '0', '0', '0', '3','0'],['0', '3', '0', '3', '0', '0','0'],
       ['0', '3', '0', '3', '0', '0','0'], ['3', '0', '0', '0', '0', '0','0'], ['0', '0', '0', '3', '0', '0','0'],['0', '3', '0', '3', '0', '0','0']]

lookup = {'0': 0, '1': 1, '2': 2, '3': 3, 'x': 4, 'y': 5, 'C': 6}

mse_arr=[]
mse_x=0
import copy
import random
import numpy as np

import matplotlib.pyplot as plt

indexing = 0
q_matrix = []


import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense
from keras.optimizers import Adam

batch_size = 6
joined_mat = np.arange(1, (len(inp) * len(inp[0])) + 1).reshape((len(inp), len(inp[0])))
inp_shape = len(inp) * len(inp[0])


def create_model():
    inp_shape = len(inp) * len(inp[0])

    model = Sequential()
    model.add(Dense(units=100, activation='relu', input_dim=inp_shape))

    model.add(Dense(inp_shape, activation='softmax'))
    return model


rlmod = create_model()

rlmod.compile(optimizer=Adam(lr=0.003),loss='mse',metrics=['mae','mse'])
def encode_mat(a, b):
    return joined_mat[a][b]


def decode_mat(v):
    for i in range(0, len(joined_mat)):
        for j in range(0, len(joined_mat[0])):
            if joined_mat[i][j] == v:
                return i, j


def getRandomNumbers(n):
    l = []
    while (len(l) <= 4):
        i = random.randint(0, n - 1)
        if i not in l:
            l.append(i)
    return l


def traverseMatrix(matrix, random_r, random_c, r, c):
    i, j = random_r, random_c
    score = 0
    if matrix[i][j] == '0':
        score += 1
        i, j = random_r, random_c
        i += 1
        c1 = 0
        while (i >= 0 and i < r and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != '2' and c1 < 4):
            score += 1
            i += 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        i -= 1
        while (i >= 0 and i < r and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != '2' and c1 < 4):
            score += 1
            i -= 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        j += 1
        while (j >= 0 and j < c and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != 2 and c1 < 4):
            score += 1
            j += 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        j -= 1
        while (j >= 0 and j < c and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != 2 and c1 < 4):
            score += 1
            j -= 1
            c1 += 1

    return score


def Player(matrix, player, eph):
    r = len(matrix)
    c = len(matrix[0])
    # generate 8 random sets of numbers within boundaries of matrix
    ind = 0
    m = {}
    random_row = getRandomNumbers(r)
    random_col = getRandomNumbers(c)
    for i in range(0, len(random_row)):
        s = traverseMatrix(matrix, random_row[i], random_col[i], r, c)

        ind += 1
        m[ind] = [s, random_row[i], random_col[i]]

    for j in range(0, len(random_row)):
        t = len(random_row) - j - 1
        s = traverseMatrix(matrix, random_row[t], random_col[j], r, c)

        ind += 1
        m[ind] = [s, random_row[t], random_col[j]]
    #print(m)
    #rowScore,colScore = playEMM(m)

    # deep
    rowScore, colScore = action_select(matrix, eph, rlmod)
    if player == 'first':
        print('f', rowScore, colScore)
        matrix = markBoardP1(matrix, rowScore, colScore, r, c)


    return matrix, rowScore, colScore


def markBoardP1(matrix, random_r, random_c, r, c):
    i, j = random_r, random_c
    if matrix[i][j] == '0':
        matrix[i][j] = '1'
        i, j = random_r, random_c
        i += 1
        c1 = 0
        while (i >= 0 and i < r and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != '2' and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'x'
            elif matrix[i][j] == 'y':
                matrix[i][j] = 'C'
            i += 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        i -= 1
        while (i >= 0 and i < r and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != '2' and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'x'
            elif matrix[i][j] == 'y':
                matrix[i][j] = 'C'
            i -= 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        j += 1
        while (j >= 0 and j < c and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != 2 and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'x'
            elif matrix[i][j] == 'y':
                matrix[i][j] = 'C'
            j += 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        j -= 1
        while (j >= 0 and j < c and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != 2 and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'x'
            elif matrix[i][j] == 'y':
                matrix[i][j] = 'C'
            j -= 1
            c1 += 1
    elif matrix[i][j] == 'x' or matrix[i][j] == 'y':
        print("wrong move p1 laser present")
    return matrix


def markBoardP2(matrix, random_r,random_c):
    r,c = len(matrix),len(matrix[0])

    i, j = random_r, random_c
    if matrix[i][j] == '0':
        matrix[i][j] = '2'
        i, j = random_r, random_c
        i += 1
        c1 = 0
        while (i >= 0 and i < r and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != '2' and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'y'
            elif matrix[i][j] == 'x':
                matrix[i][j] = 'C'
            i += 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        i -= 1
        while (i >= 0 and i < r and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != '2' and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'y'
            elif matrix[i][j] == 'x':
                matrix[i][j] = 'C'
            i -= 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        j += 1
        while (j >= 0 and j < c and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != 2 and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'y'
            elif matrix[i][j] == 'x':
                matrix[i][j] = 'C'
            j += 1
            c1 += 1

        i, j = random_r, random_c
        c1 = 0
        j -= 1
        while (j >= 0 and j < c and matrix[i][j] != '3' and matrix[i][j] != '1' and matrix[i][j] != 2 and c1 < 4):
            if matrix[i][j] == '0':
                matrix[i][j] = 'y'
            elif matrix[i][j] == 'x':
                matrix[i][j] = 'C'
            j -= 1
            c1 += 1
    elif matrix[i][j] == 'x' or matrix[i][j] == 'y':
        print("wrong move p2 laser present")
    return matrix,random_r,random_c


def chanceMode(minmap):
    i = 1
    t = 0
    chanceScoreMap = {}
    while (i < len(minmap)):
        random_var = random.randint(0, 1)
        if random_var == 0:
            t += 1
            chanceScoreMap[t] = minmap[i]
        elif random_var == 1:
            t += 1
            chanceScoreMap[t] = minmap[i + 1]
        i += 2
    return chanceScoreMap


def playEMM(scoresMap):
    # key is index and values = score,row,col
    maxMap = maximizeS(scoresMap)
    print('maxMap', maxMap)
    minMap = minimizeS(maxMap)
    print('minMap', minMap)
    finalmaxMap = chanceMode(minMap)
    print('chanceMap', finalmaxMap)
    return (finalmaxMap[1][1], finalmaxMap[1][2])


def minimizeS(scoresMap):
    i = 1
    t = 0
    minScoreMap = {}
    while (i < len(scoresMap)):
        if scoresMap[i][0] <= scoresMap[i + 1][0]:
            t += 1
            minScoreMap[t] = scoresMap[i]
        else:
            t += 1
            minScoreMap[t] = scoresMap[i + 1]
        i += 2
    return minScoreMap


def maximizeS(scoresMap):
    i = 1
    t = 0
    maxScoreMap = {}
    while (i < len(scoresMap)):
        if scoresMap[i][0] >= scoresMap[i + 1][0]:
            t += 1
            maxScoreMap[t] = scoresMap[i]
        else:
            t += 1
            maxScoreMap[t] = scoresMap[i + 1]
        i += 2
    return maxScoreMap


def playGame(matrix, idx, eph,count_p1,count_p2):
    # test_matrix from main
    t = 0
    print(matrix)
    done = 0
    while (t < 5):
        if (t == 4):
            done = 1
        else:
            done = 0
        r = 0
        p_mat = matrix
        n_mat, r1, c1 = Player(p_mat, 'first', eph)
        q_matrix.append([p_mat, n_mat, encode_mat(r1, c1), r, done])

        #f_matrix, r2, c2 = Player(n_mat, 'second', eph)
        randr=0
        randc=0
        while(matrix[randr].count('0')<=0):
            randr+=1
        while (matrix[randr][randc] != '0'):
            randc += 1

        f_matrix, r2, c2 = markBoardP2(n_mat,randr,randc)
        (p1, p2, z) = calScore(f_matrix)
        print(matrix)
        print("p1,p2:", p1, p2)
        if p1 > p2:
            r = 1
            count_p1+=1
        elif p1 < p2:
            r = -1
            count_p2+=1
        else:
            r = 0

        q_matrix.append([n_mat, f_matrix, encode_mat(r2, c2), r, done])
        if len(q_matrix)>25:
            learn(rlmod)
        if z == 0:
            print("no space left break")
            print("p1,p2:", p1, p2)
            break
        t += 1
    print("count_p1, count_p2: ", count_p1,count_p2)
    return count_p1,count_p2


def calScore(m):
    s1 = 0
    s2 = 0
    countZeroes = 0
    for i in m:
        s1 += i.count('x')
        s1 += i.count('1')
        s2 += i.count('y')
        s2 += i.count('2')
        s1 += i.count('C')
        s2 += i.count('C')
        countZeroes += i.count('0')

    # print("p1,p2:", s1, s2)
    return (s1, s2, countZeroes)


def sample(batch_size):
    sample = zip(*random.sample(q_matrix, batch_size))
    return sample


gamma = 0.9


def preProcess(m):
    test_matrix1 = copy.deepcopy(m)
    for i in range(0, len(m)):
        for j in range(0, len(m[0])):
            test_matrix1[i][j] = lookup[m[i][j]]

    return test_matrix1


def learn(rlmod):
    Pobs, Nobs, a, r, d = sample(6)  # random samples from memory
    pob=[]
    Nob=[]
    z=0
    while(z<6):
        Pobs1 = preProcess(Pobs[z])
        Nobs1 = preProcess(Nobs[z])
        pob.append(Pobs1)
        Nob.append(Nobs1)
        z+=1
    #print(np.array(pob),batch_size,inp_shape)
    pred_target = rlmod.predict(np.array(pob).reshape(batch_size, inp_shape))  # predicted q-values
    next_op1 = rlmod.predict(np.array(Nob).reshape(batch_size, inp_shape))  # actual q-values
    for i in range(batch_size):
        k = a[i]-1  # k is the index of action of the action taken
        if d == 0:
            target = r[i] + gamma * np.amax(next_op1[i][:])  # For non terminal states
        else:
            target = r[i]
        pred_target[i][k] = target
    l = rlmod.fit(np.array(pob).reshape(batch_size, inp_shape),
              pred_target.reshape(batch_size, inp_shape), epochs=25, batch_size=6, verbose=0)  # training the network to approximate q-values

    mse_arr.append(l.history['loss'])

def action_select(matrix, eph, rlmod):
    matrix = preProcess(matrix)

    q_out = rlmod.predict_on_batch(np.array(matrix).reshape(1, inp_shape))
    action = np.argmax(q_out)
    # row, col = decode_mat(action)
    act = np.array([random.randint(1, 26), random.randint(1, 26), action])
    val = np.random.choice(act, p=[(eph / 2), (eph / 2), (1 - eph)])
    print(val)
    if val!=0:
        row, col = decode_mat(val)
        return row, col


def main():
    # create_model()
    t = 0
    inp_shape = len(inp) * len(inp[0])
    #rlmod = create_model()
    #rlmod.compile(optimizer=Adam(lr=0.004), loss='mse', metrics=['mae', 'mse'])
    player1=0
    player2=0
    while (t < 100):
        count_p1 = 0
        count_p2 = 0
        test_matrix = copy.deepcopy(inp)
        p1,p2 =playGame(test_matrix, indexing, 0.90,count_p1,count_p2)
        if p1>=p2:
            player1+=1
        elif p1<=p2:
            player2+=1
        t += 1
    print("total games played: ",t)
    print("total wins by player 1 and player 2: ",player1,player2)
    #print(len(mse_arr))
    plt.plot(mse_arr)
    plt.ylabel('loss')
    plt.xlabel('at each iteration')
    plt.show()
main()